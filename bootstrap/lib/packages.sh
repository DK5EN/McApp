#!/bin/bash
# packages.sh - Package management for MCProxy bootstrap
# Handles: apt packages, uv, Caddy, lighttpd, Python venv

#──────────────────────────────────────────────────────────────────
# MAIN PACKAGE INSTALLATION
#──────────────────────────────────────────────────────────────────

install_packages() {
  install_apt_deps
  install_uv
  install_caddy
  install_lighttpd
  setup_python_venv
}

#──────────────────────────────────────────────────────────────────
# APT DEPENDENCIES
#──────────────────────────────────────────────────────────────────

install_apt_deps() {
  log_info "Installing system dependencies..."

  # Update package lists
  apt-get update -qq

  # Core dependencies
  local -a packages=(
    # Essential tools
    "curl"
    "jq"
    "bc"
    "screen"
    "git"

    # Python (version depends on Debian release)
    "python3"
    "python3-venv"
    "python3-pip"

    # BlueZ for BLE support
    "bluez"
    "bluetooth"

    # For D-Bus (required by dbus_next)
    "libdbus-1-dev"

    # For SSL certificates
    "ca-certificates"
    "gnupg"
  )

  # Install all packages
  DEBIAN_FRONTEND=noninteractive apt-get install -y -qq "${packages[@]}"

  log_ok "  System dependencies installed"
}

#──────────────────────────────────────────────────────────────────
# UV PACKAGE MANAGER
#──────────────────────────────────────────────────────────────────

install_uv() {
  log_info "Installing uv package manager..."

  if command -v uv &>/dev/null; then
    local uv_version
    uv_version=$(uv --version 2>/dev/null | head -1)
    log_info "  uv already installed: ${uv_version}"
    return 0
  fi

  # Install uv using official installer
  curl -LsSf https://astral.sh/uv/install.sh | sh

  # Add to PATH for current session
  export PATH="$HOME/.local/bin:$PATH"

  # Verify installation
  if command -v uv &>/dev/null; then
    local uv_version
    uv_version=$(uv --version 2>/dev/null | head -1)
    log_ok "  uv installed: ${uv_version}"
  else
    log_error "  Failed to install uv"
    return 1
  fi
}

#──────────────────────────────────────────────────────────────────
# CADDY REVERSE PROXY
#──────────────────────────────────────────────────────────────────

install_caddy() {
  log_info "Installing Caddy reverse proxy..."

  local keyring="/usr/share/keyrings/caddy-stable-archive-keyring.gpg"
  local repo_file="/etc/apt/sources.list.d/caddy-stable.list"

  # Check if already installed
  if command -v caddy &>/dev/null; then
    local caddy_version
    caddy_version=$(caddy version 2>/dev/null | head -1)
    log_info "  Caddy already installed: ${caddy_version}"

    # Still update repo for correct Debian version
    update_caddy_repo
    configure_caddy
    return 0
  fi

  # Add Caddy GPG key
  curl -fsSL https://dl.cloudsmith.io/public/caddy/stable/gpg.key \
    | gpg --dearmor -o "$keyring"

  # Add repository (version-aware)
  update_caddy_repo

  # Install Caddy
  apt-get update -qq
  apt-get install -y -qq caddy

  # Configure Caddy
  configure_caddy

  log_ok "  Caddy installed and configured"
}

update_caddy_repo() {
  local repo_file="/etc/apt/sources.list.d/caddy-stable.list"
  local keyring="/usr/share/keyrings/caddy-stable-archive-keyring.gpg"
  local repo_line

  repo_line=$(get_caddy_repo)

  echo "$repo_line" > "$repo_file"
  log_info "  Caddy repo updated for $(get_debian_codename)"
}

configure_caddy() {
  log_info "  Configuring Caddy..."

  local caddyfile="/etc/caddy/Caddyfile"
  local hostname

  # Get hostname from config or system
  if [[ -f "$CONFIG_FILE" ]] && command -v jq &>/dev/null; then
    hostname=$(jq -r '.HOSTNAME // ""' "$CONFIG_FILE" 2>/dev/null)
  fi
  [[ -z "$hostname" ]] && hostname=$(hostname -s)

  # Generate Caddyfile
  cat > "$caddyfile" << EOF
# MCProxy Caddy configuration
# Generated by mcproxy.sh bootstrap

# Global options
{
    # Use internal CA for local TLS
    local_certs
    auto_https disable_redirects
}

# Main HTTPS site
https://${hostname}.local {
    # Serve static webapp
    handle /webapp/* {
        root * /var/www/html
        file_server
    }

    # Root certificate download
    handle /root.crt {
        root * /var/lib/caddy/.local/share/caddy/pki/authorities/local
        rewrite * /root.crt
        file_server
    }

    # Default: redirect to webapp
    handle {
        redir /webapp/ permanent
    }
}

# WebSocket proxy (separate port for WSS)
https://${hostname}.local:2981 {
    reverse_proxy localhost:2980
}
EOF

  # Validate Caddyfile
  if caddy validate --config "$caddyfile" 2>/dev/null; then
    log_info "  Caddyfile validated"
  else
    log_warn "  Caddyfile validation failed, check configuration"
  fi
}

#──────────────────────────────────────────────────────────────────
# LIGHTTPD (Static File Server)
#──────────────────────────────────────────────────────────────────

install_lighttpd() {
  log_info "Installing lighttpd..."

  # Check if already installed
  if command -v lighttpd &>/dev/null; then
    log_info "  lighttpd already installed"
    configure_lighttpd
    return 0
  fi

  apt-get install -y -qq lighttpd

  configure_lighttpd

  log_ok "  lighttpd installed and configured"
}

configure_lighttpd() {
  log_info "  Configuring lighttpd..."

  local conf_file="/etc/lighttpd/conf-available/99-mcproxy.conf"
  local marker="# MCProxy SPA rewrite"

  # Check if already configured
  if [[ -f "$conf_file" ]] && grep -q "$marker" "$conf_file" 2>/dev/null; then
    log_info "  lighttpd already configured"
    return 0
  fi

  # Create MCProxy-specific config
  cat > "$conf_file" << 'EOF'
# MCProxy SPA rewrite configuration
# Enables Vue.js SPA routing

server.modules += ("mod_rewrite")

$HTTP["url"] =~ "^/webapp/" {
    url.rewrite-if-not-file = (
        "^/webapp/(.*)$" => "/webapp/index.html"
    )
}
EOF

  # Enable the config (idempotent)
  if [[ ! -L /etc/lighttpd/conf-enabled/99-mcproxy.conf ]]; then
    ln -sf "$conf_file" /etc/lighttpd/conf-enabled/99-mcproxy.conf
  fi

  # Test config before reloading
  if lighttpd -t -f /etc/lighttpd/lighttpd.conf 2>/dev/null; then
    systemctl reload lighttpd 2>/dev/null || systemctl restart lighttpd
  else
    log_warn "  lighttpd config test failed"
  fi
}

#──────────────────────────────────────────────────────────────────
# PYTHON VIRTUAL ENVIRONMENT
#──────────────────────────────────────────────────────────────────

setup_python_venv() {
  log_info "Setting up Python virtual environment..."

  local python_version
  local python_exec

  python_version=$(get_python_version)
  python_exec=$(get_python_executable)

  if [[ -z "$python_exec" ]]; then
    log_error "  Python not found"
    return 1
  fi

  log_info "  Using Python ${python_version} (${python_exec})"

  # Check if venv exists and is valid
  if venv_is_valid; then
    log_info "  Existing venv is valid, updating packages..."
    update_venv_packages
    return 0
  fi

  # Remove broken venv if exists
  [[ -d "$VENV_DIR" ]] && rm -rf "$VENV_DIR"

  # Create venv using uv (preferred) or fallback to venv module
  if command -v uv &>/dev/null; then
    log_info "  Creating venv with uv..."
    uv venv "$VENV_DIR" --python "$python_exec"
  else
    log_info "  Creating venv with python -m venv..."
    "$python_exec" -m venv "$VENV_DIR"
  fi

  # Install packages
  install_venv_packages

  log_ok "  Python venv created at ${VENV_DIR}"
}

install_venv_packages() {
  log_info "  Installing Python packages..."

  local requirements_file

  # Find requirements file
  if [[ -f "${SCRIPT_DIR}/requirements.txt" ]]; then
    requirements_file="${SCRIPT_DIR}/requirements.txt"
  elif [[ -f "${SHARE_DIR}/requirements.txt" ]]; then
    requirements_file="${SHARE_DIR}/requirements.txt"
  else
    # Create minimal requirements inline
    requirements_file=$(mktemp)
    cat > "$requirements_file" << 'EOF'
# MCProxy Python dependencies (minimum versions)
websockets>=14.0
dbus-next>=0.2.3
timezonefinder>=6.5.0
httpx>=0.28.0
zstandard>=0.23.0
EOF
    trap "rm -f $requirements_file" EXIT
  fi

  # Install using uv pip (preferred) or regular pip
  if command -v uv &>/dev/null; then
    uv pip install --python "${VENV_DIR}/bin/python" -r "$requirements_file"
  else
    "${VENV_DIR}/bin/pip" install --upgrade pip
    "${VENV_DIR}/bin/pip" install -r "$requirements_file"
  fi

  log_ok "  Python packages installed"
}

update_venv_packages() {
  log_info "  Updating Python packages..."

  local requirements_file

  # Find requirements file
  if [[ -f "${SCRIPT_DIR}/requirements.txt" ]]; then
    requirements_file="${SCRIPT_DIR}/requirements.txt"
  elif [[ -f "${SHARE_DIR}/requirements.txt" ]]; then
    requirements_file="${SHARE_DIR}/requirements.txt"
  else
    log_info "  No requirements file found, skipping update"
    return 0
  fi

  # Update using uv pip (preferred) or regular pip
  if command -v uv &>/dev/null; then
    uv pip install --python "${VENV_DIR}/bin/python" --upgrade -r "$requirements_file"
  else
    "${VENV_DIR}/bin/pip" install --upgrade -r "$requirements_file"
  fi

  log_ok "  Python packages updated"
}
