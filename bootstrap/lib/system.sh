#!/bin/bash
# system.sh - System configuration for MCProxy bootstrap
# Handles: tmpfs, firewall, journald, service hardening

#──────────────────────────────────────────────────────────────────
# MAIN SYSTEM SETUP FUNCTION
#──────────────────────────────────────────────────────────────────

setup_system() {
  configure_tmpfs
  configure_journald
  configure_firewall
  configure_bluetooth
  configure_unattended_upgrades
  disable_unused_services
  configure_ssh_hardening
}

#──────────────────────────────────────────────────────────────────
# TMPFS CONFIGURATION (SD Card Protection)
#──────────────────────────────────────────────────────────────────

configure_tmpfs() {
  log_info "Configuring tmpfs for SD card longevity..."

  local fstab="/etc/fstab"
  local marker="# MCProxy tmpfs"
  local needs_remount=false

  # Check if already configured
  if grep -q "$marker" "$fstab" 2>/dev/null; then
    log_info "  tmpfs already configured in fstab"
    return 0
  fi

  # Backup fstab
  cp "$fstab" "${fstab}.bak.$(date +%Y%m%d)"

  # Add tmpfs entries
  cat >> "$fstab" << EOF

${marker} - begin
tmpfs /var/log tmpfs defaults,noatime,nosuid,mode=0755,size=30M 0 0
tmpfs /tmp tmpfs defaults,noatime,nosuid,mode=1777,size=50M 0 0
${marker} - end
EOF

  log_ok "  tmpfs entries added to fstab"

  # Create log directory structure in tmpfs after mount
  mkdir -p /etc/tmpfiles.d
  cat > /etc/tmpfiles.d/mcproxy.conf << 'EOF'
# MCProxy log directories
d /var/log/mcproxy 0755 root root -
d /var/log/caddy 0755 caddy caddy -
d /var/log/lighttpd 0755 www-data www-data -
EOF

  log_info "  Mounting tmpfs (will be permanent after reboot)..."

  # Mount if not already mounted
  if ! mountpoint -q /tmp; then
    mount -t tmpfs -o defaults,noatime,nosuid,mode=1777,size=50M tmpfs /tmp || true
  fi

  # Note: /var/log mount is tricky on running system, skip for now
  log_warn "  Note: /var/log tmpfs will be active after next reboot"
}

#──────────────────────────────────────────────────────────────────
# JOURNALD CONFIGURATION (Volatile Storage)
#──────────────────────────────────────────────────────────────────

configure_journald() {
  log_info "Configuring journald for volatile storage..."

  local conf_dir="/etc/systemd/journald.conf.d"
  local conf_file="${conf_dir}/mcproxy-volatile.conf"

  mkdir -p "$conf_dir"

  # Check if already configured
  if [[ -f "$conf_file" ]]; then
    log_info "  journald already configured"
    return 0
  fi

  cat > "$conf_file" << 'EOF'
# MCProxy: Use volatile storage to protect SD card
[Journal]
Storage=volatile
RuntimeMaxUse=20M
RuntimeKeepFree=10M
RuntimeMaxFileSize=5M
MaxRetentionSec=1week
EOF

  log_ok "  journald configured for volatile storage"

  # Restart journald to apply
  systemctl restart systemd-journald || true
}

#──────────────────────────────────────────────────────────────────
# FIREWALL CONFIGURATION (nftables)
#──────────────────────────────────────────────────────────────────

configure_firewall() {
  log_info "Configuring firewall..."

  local codename
  codename=$(get_debian_codename)

  # Use nftables for Trixie+, iptables for older
  if [[ "$codename" == "trixie" ]] || [[ "$codename" == "sid" ]]; then
    configure_nftables
  else
    configure_iptables_legacy
  fi
}

configure_nftables() {
  log_info "  Using nftables (Trixie)"

  # Install nftables if not present
  if ! command -v nft &>/dev/null; then
    apt-get update -qq
    apt-get install -y -qq nftables
  fi

  local nft_conf="/etc/nftables.conf"
  local marker="# MCProxy firewall rules"

  # Check if our rules already exist
  if grep -q "$marker" "$nft_conf" 2>/dev/null; then
    log_info "  nftables rules already configured"
    return 0
  fi

  # Backup existing config
  [[ -f "$nft_conf" ]] && cp "$nft_conf" "${nft_conf}.bak.$(date +%Y%m%d)"

  cat > "$nft_conf" << 'EOF'
#!/usr/sbin/nft -f
# MCProxy firewall rules
# Generated by mcproxy.sh bootstrap

flush ruleset

table inet filter {
  chain input {
    type filter hook input priority 0; policy drop;

    # Allow loopback
    iif lo accept

    # Allow established/related connections
    ct state established,related accept

    # SSH (rate limited)
    tcp dport 22 ct state new limit rate 3/minute accept

    # HTTPS (Caddy reverse proxy)
    tcp dport 443 accept

    # WebSocket over TLS
    tcp dport 2981 accept

    # MeshCom UDP
    udp dport 1799 accept

    # mDNS for .local hostname resolution (avahi)
    udp dport 5353 accept

    # ICMP (ping)
    icmp type echo-request accept
    icmpv6 type echo-request accept

    # Log and drop everything else
    log prefix "[nftables DROP] " flags all counter drop
  }

  chain forward {
    type filter hook forward priority 0; policy drop;
  }

  chain output {
    type filter hook output priority 0; policy accept;
  }
}
EOF

  # Enable and start nftables
  systemctl enable nftables
  systemctl restart nftables

  log_ok "  nftables firewall configured and enabled"
}

configure_iptables_legacy() {
  log_info "  Using iptables (Bookworm fallback)"

  # Install iptables-persistent if not present
  if ! dpkg -l iptables-persistent &>/dev/null; then
    # Pre-answer debconf questions to avoid interactive prompt
    echo iptables-persistent iptables-persistent/autosave_v4 boolean true | debconf-set-selections
    echo iptables-persistent iptables-persistent/autosave_v6 boolean true | debconf-set-selections
    apt-get update -qq
    apt-get install -y -qq iptables-persistent
  fi

  # Flush existing rules
  iptables -F
  iptables -X

  # Default policies
  iptables -P INPUT DROP
  iptables -P FORWARD DROP
  iptables -P OUTPUT ACCEPT

  # Allow loopback
  iptables -A INPUT -i lo -j ACCEPT

  # Allow established connections
  iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

  # SSH with rate limiting
  iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --set
  iptables -A INPUT -p tcp --dport 22 -m state --state NEW -m recent --update --seconds 60 --hitcount 4 -j DROP
  iptables -A INPUT -p tcp --dport 22 -j ACCEPT

  # HTTPS, WSS, MeshCom UDP, mDNS
  iptables -A INPUT -p tcp --dport 443 -j ACCEPT
  iptables -A INPUT -p tcp --dport 2981 -j ACCEPT
  iptables -A INPUT -p udp --dport 1799 -j ACCEPT
  iptables -A INPUT -p udp --dport 5353 -j ACCEPT

  # ICMP
  iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT

  # Save rules
  iptables-save > /etc/iptables/rules.v4

  log_ok "  iptables firewall configured and saved"
}

#──────────────────────────────────────────────────────────────────
# BLUETOOTH RFKILL FIX
#──────────────────────────────────────────────────────────────────

configure_bluetooth() {
  log_info "Configuring Bluetooth rfkill unblock..."

  local service_file="/etc/systemd/system/unblock-bluetooth.service"

  # Check if already configured
  if [[ -f "$service_file" ]]; then
    log_info "  Bluetooth unblock service already configured"
    return 0
  fi

  # Check if rfkill is blocking bluetooth by default
  # This is common on Pi images with /etc/modprobe.d/rfkill_default.conf
  if [[ -f /etc/modprobe.d/rfkill_default.conf ]]; then
    if grep -q "default_state=0" /etc/modprobe.d/rfkill_default.conf 2>/dev/null; then
      log_info "  Detected rfkill default_state=0 (radios blocked at boot)"
    fi
  fi

  # Install the service from template
  cp "${BOOTSTRAP_DIR}/templates/unblock-bluetooth.service" "$service_file"

  # Enable the service
  systemctl daemon-reload
  systemctl enable unblock-bluetooth

  # Unblock now if currently blocked
  if command -v rfkill &>/dev/null; then
    if rfkill list bluetooth 2>/dev/null | grep -q "Soft blocked: yes"; then
      rfkill unblock bluetooth
      log_info "  Bluetooth was blocked, unblocked now"
    fi
  fi

  log_ok "  Bluetooth unblock service installed and enabled"
}

#──────────────────────────────────────────────────────────────────
# UNATTENDED UPGRADES
#──────────────────────────────────────────────────────────────────

configure_unattended_upgrades() {
  log_info "Configuring unattended security upgrades..."

  # Install if not present
  if ! dpkg -l unattended-upgrades &>/dev/null; then
    apt-get update -qq
    apt-get install -y -qq unattended-upgrades
  fi

  local codename
  codename=$(get_debian_codename)

  # Configure which updates to apply
  cat > /etc/apt/apt.conf.d/50unattended-upgrades << EOF
// MCProxy: Automatic security updates
Unattended-Upgrade::Origins-Pattern {
    "origin=Debian,codename=${codename},label=Debian-Security";
    "origin=Debian,codename=${codename}-security,label=Debian-Security";
};

// Don't automatically reboot
Unattended-Upgrade::Automatic-Reboot "false";

// Clean up old packages
Unattended-Upgrade::Remove-Unused-Dependencies "true";

// Log to syslog
Unattended-Upgrade::SyslogEnable "true";
EOF

  # Enable automatic updates
  cat > /etc/apt/apt.conf.d/20auto-upgrades << 'EOF'
APT::Periodic::Update-Package-Lists "1";
APT::Periodic::Unattended-Upgrade "1";
APT::Periodic::AutocleanInterval "7";
EOF

  log_ok "  Unattended upgrades configured (security updates only)"
}

#──────────────────────────────────────────────────────────────────
# DISABLE UNUSED SERVICES
#──────────────────────────────────────────────────────────────────

disable_unused_services() {
  log_info "Disabling unused services..."

  # Services safe to disable on a headless Pi
  local -a disable_services=(
    "cups"
    "cups-browsed"
    "ModemManager"
    "triggerhappy"
  )

  for svc in "${disable_services[@]}"; do
    if systemctl is-enabled --quiet "$svc" 2>/dev/null; then
      systemctl disable --now "$svc" 2>/dev/null || true
      log_info "  Disabled: $svc"
    fi
  done

  # DO NOT disable these (required for MCProxy):
  # - avahi-daemon (mDNS for .local resolution)
  # - bluetooth (BLE for ESP32 communication)
  # - wpa_supplicant (WiFi connectivity)

  log_ok "  Unused services disabled"
}

#──────────────────────────────────────────────────────────────────
# SSH HARDENING
#──────────────────────────────────────────────────────────────────

configure_ssh_hardening() {
  log_info "Configuring SSH hardening..."

  local ssh_conf_dir="/etc/ssh/sshd_config.d"
  local ssh_conf="${ssh_conf_dir}/mcproxy-hardening.conf"

  mkdir -p "$ssh_conf_dir"

  # Check if already configured
  if [[ -f "$ssh_conf" ]]; then
    log_info "  SSH hardening already configured"
    return 0
  fi

  cat > "$ssh_conf" << 'EOF'
# MCProxy SSH hardening
PermitRootLogin no
MaxAuthTries 3
MaxSessions 3
LoginGraceTime 30
ClientAliveInterval 300
ClientAliveCountMax 2

# Note: PasswordAuthentication left as-is
# Users should manually disable after setting up keys
EOF

  # Validate sshd config before restarting
  if sshd -t 2>/dev/null; then
    systemctl reload sshd || true
    log_ok "  SSH hardening applied"
  else
    rm -f "$ssh_conf"
    log_warn "  SSH config invalid, hardening skipped"
  fi
}
